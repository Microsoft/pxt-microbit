# Flappy bird 

## ~avatar avatar

All the fun from Flappy bird game is coming to @boardname@

## ~

This is a simple version of Flappy bird game for @boardname@. The objective is to direct a flying bird who moves continuously to the right, between sets of obstacles. If the player touches the obstacle, they lose. The purpose of this tutorial is to teach basics of game sprites, arrays, loops.

## Step 1: Add the Bird to the Game

First, we are going to add sprite of the bird from **Game** menu and make it blink. 

```blocks
let bird: game.LedSprite = null
bird = game.createSprite(0, 2)
bird.set(LedSpriteProperty.Blink, 300)
```

## Step 2: Make the Bird fly

Before we go deeper let's add some controls so that we can move around. We will control the bird by pressing **A** button to go up or **B** button to go down. 

```blocks
let bird: game.LedSprite = null

input.onButtonPressed(Button.A, () => {
    bird.change(LedSpriteProperty.Y, -1)
})
input.onButtonPressed(Button.B, () => {
    bird.change(LedSpriteProperty.Y, 1)
})
```


## Step 3: Generating obstacles

This is where things will start to get interesting. We are going to randomly generate obstacles. We will keep all obstacles inside the array. All obstacles will have one hole for bird to fly through. 

First create array of `obstacles` which will hold all obstacle sprites. 

```blocks
let obstacles: game.LedSprite[] = []
```

Now generate vertical obstacles consisting of 4 sprites and 1 random hole. 
Create new variable `emptyObstacleY`. Using ``||math:pick random||`` generate a random number from `0` to `4` and store it inside `emptyObstacleY`. 

Using ``||loops:for index||`` iterate from `0` to `4`. For all coordinates not equal to `emptyObstacleY` create and add obstacle sprites to `obstacles` end of array.

```blocks
let emptyObstacleY = 0
let obstacles: game.LedSprite[] = []

emptyObstacleY = Math.random(5)
for (let index = 0; index <= 4; index++) {
    if (index != emptyObstacleY) {
        obstacles.push(game.createSprite(4, index))
    }
}
``` 

At this point on every @boardname@ restart you should see different autogenerated vertical obstacles. 

Before continuing make sure that obstacles are generated randomly, the bird is moving up and down.

```blocks
let emptyObstacleY = 0
let obstacles: game.LedSprite[] = []
let bird: game.LedSprite = null

bird = game.createSprite(0, 2)
bird.set(LedSpriteProperty.Blink, 300)

emptyObstacleY = Math.random(5)
for (let index = 0; index <= 4; index++) {
    if (index != emptyObstacleY) {
        obstacles.push(game.createSprite(4, index))
    }
}


input.onButtonPressed(Button.A, () => {
    bird.change(LedSpriteProperty.Y, -1)
})

input.onButtonPressed(Button.B, () => {
    bird.change(LedSpriteProperty.Y, 1)
})
```


## Step 4: Make obstacles move

Iterate over `obstacles` array and decrease `obstacle` `X` coordinate by 1.
```blocks
let obstacles: game.LedSprite[] = []

basic.forever(() => {
    for (let obstacle of obstacles) {
        obstacle.change(LedSpriteProperty.X, -1)
    }
    basic.pause(1000)
})
```

Obstacles should move towards left every second. 

## Step 5: Make obstacles disappear

Make obstacles disappear after reaching leftmost corner. Iterate over all obstacles, delete obstacle sprites with `X = 0` coordinate and remove it from `obstacles` array. 

 ```blocks
let obstacles: game.LedSprite[] = []

basic.forever(() => {
    while (obstacles.length > 0 && obstacles[0].get(LedSpriteProperty.X) == 0) {
        obstacles.removeAt(0).delete()
    }

    for (let obstacle of obstacles) {
        obstacle.change(LedSpriteProperty.X, -1)
    }
    basic.pause(1000)
})
```

## Step 6: Generate more obstacles

At the moment, our code generates just one vertical obstacle. We need to put obstacle generation code into a ``||basic:forever||`` so that it keeps generating more and more obstacles.

```blocks
let emptyObstacleY = 0
let obstacles: game.LedSprite[] = []

basic.forever(() => {
    while (obstacles.length > 0 && obstacles[0].get(LedSpriteProperty.X) == 0) {
        obstacles.removeAt(0).delete()
    }

    for (let obstacle of obstacles) {
        obstacle.change(LedSpriteProperty.X, -1)
    }
    emptyObstacleY = Math.random(5)
    for (let index = 0; index <= 4; index++) {
        if (index != emptyObstacleY) {
            obstacles.push(game.createSprite(4, index))
        }
    }
    basic.pause(1000)
})
```

Now our screen is full of moving obstacles. Create some spaces between generated obstacles. Let's introduce `ticks` variable to count how many iterations forever loop done and execute obstacle creation only if `ticks` is divisible by 3. 

```blocks
let ticks = 0
let emptyObstacleY = 0
let obstacles: game.LedSprite[] = []

basic.forever(() => {
    while (obstacles.length > 0 && obstacles[0].get(LedSpriteProperty.X) == 0) {
        obstacles.removeAt(0).delete()
    }

    for (let obstacle of obstacles) {
        obstacle.change(LedSpriteProperty.X, -1)
    }
    if (ticks % 3 == 0) {
        emptyObstacleY = Math.random(5)
        for (let index = 0; index <= 4; index++) {
            if (index != emptyObstacleY) {
                obstacles.push(game.createSprite(4, index))
            }
        }
    }
    ticks += 1
    basic.pause(1000)
})
```

## Step 7: Game Over

Nothing happens when the bird is hit by obstacle. Fix this by iterating over `obstacles` array and checking if obstacle sprite coordinate equals bird coordinate. 

```blocks
let bird: game.LedSprite = null
let ticks = 0
let emptyObstacleY = 0
let obstacles: game.LedSprite[] = []

basic.forever(() => {
    while (obstacles.length > 0 && obstacles[0].get(LedSpriteProperty.X) == 0) {
        obstacles.removeAt(0).delete()
    }

    for (let obstacle of obstacles) {
        obstacle.change(LedSpriteProperty.X, -1)
    }
    if (ticks % 3 == 0) {
        emptyObstacleY = Math.random(5)
        for (let index = 0; index <= 4; index++) {
            if (index != emptyObstacleY) {
                obstacles.push(game.createSprite(4, index))
            }
        }
    }

    for (let obstacle of obstacles) {
        if (obstacle.get(LedSpriteProperty.X) == bird.get(LedSpriteProperty.X) && obstacle.get(LedSpriteProperty.Y) == bird.get(LedSpriteProperty.Y)) {
            game.gameOver()
        }
    }

    ticks += 1
    basic.pause(1000)
})
```

## The final code

```blocks
let ticks = 0
let emptyObstacleY = 0
let obstacles: game.LedSprite[] = []
let index = 0
let bird: game.LedSprite = null
input.onButtonPressed(Button.A, () => {
    bird.change(LedSpriteProperty.Y, -1)
})
input.onButtonPressed(Button.B, () => {
    bird.change(LedSpriteProperty.Y, 1)
})
let obstacle = 0
index = 0
obstacle = null
obstacles = []
bird = game.createSprite(0, 2)
bird.set(LedSpriteProperty.Blink, 300)
basic.forever(() => {
    while (obstacles.length > 0 && obstacles[0].get(LedSpriteProperty.X) == 0) {
        obstacles.removeAt(0).delete()
    }
    for (let obstacle2 of obstacles) {
        obstacle2.change(LedSpriteProperty.X, -1)
    }
    if (ticks % 3 == 0) {
        emptyObstacleY = Math.random(5)
        for (let index2 = 0; index2 <= 4; index2++) {
            if (index2 != emptyObstacleY) {
                obstacles.push(game.createSprite(4, index2))
            }
        }
    }
    for (let obstacle3 of obstacles) {
        if (obstacle3.get(LedSpriteProperty.X) == bird.get(LedSpriteProperty.X) && obstacle3.get(LedSpriteProperty.Y) == bird.get(LedSpriteProperty.Y)) {
            game.gameOver()
        }
    }
    ticks += 1
    basic.pause(1000)
})
```

## Exercises
1. Count Flappy Bird game score.
2. Make obstacles move faster on every obstacle passed.

## About the authors

This project was created by [Karolis Vycius](https://www.linkedin.com/in/vycius/). Originally Flappy Bird game was developed by [Dong Nguyen](https://en.wikipedia.org/wiki/Flappy_Bird)
